var events	= require('events');
var child	= require('child_process');

module.exports = function(target){
	function data(str){
		parse(str, function(data) {
			obj.emit('data', data);
		});
	}

	function parse(str, callback) {
		var clean = str.trim().replace(/\s+/g, ' ');
		var lines = str.split("\n").filter(function(val){ return val; });

		var match = clean.match(/^(\d+)(\s(.*?) \((.*?)\)\s|\s)(([\d\.]+) ms|\*)(\s!([A-Z])\s|\s)(([\d\.]+) ms|\*)(\s!([A-Z])\s|\s)(([\d\.]+) ms|\*)(\s!([A-Z])|)$/);
		if (!match) {
			if (lines.length > 1) {
				lines.forEach(function(line){
					parse(line, callback);
				});
			} else {
				if (previous) {
					previous = '' + previous + ' ' + str;
					previous = '';
					parse(previous, callback);
				} else {
					previous = clean;
				}
			}
		} else {
			callback({
				no: +match[1],
				target: {
					host: match[3] || null,
					ip: match[4] || null
				},
				rtt: [
					{
						error: error(match[8]),
						time: +match[6] || null
					},
					{
						error: error(match[12]),
						time: +match[10] || null
					},
					{
						error: error(match[16]),
						time: +match[14] || null
					}
				]
			});
		}
	}

	function error(str){
		str = String(str).toLowerCase();
		switch (str) {
			case 'h':
				return 'Host unreachable';
			case 'n':
				return 'Network unreachable';
			case 'p':
				return 'Protocol unreachable';
			case 's':
				return 'Source route failed';
			case 'f':
				return 'Fragmentation needed';
			case 'x':
				return 'Communication administratively prohibited';
			default:
				return null;
		}
	}

	var obj = new events.EventEmitter;
	var previous;

	var spawn = child.spawn('traceroute', [target]);

	spawn.on('exit', function(){
		obj.emit('exit');
	});

	spawn.stdout.setEncoding('utf8');
	spawn.stdout.once('data', function(str){
		spawn.stdout.on('data', data);
	});

	return obj;
};